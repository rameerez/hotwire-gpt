
# [Hotwire](https://hotwired.dev/)

Hotwire: HTML Over The Wire

**Hotwire is an alternative approach to building modern web applications without using much JavaScript by sending HTML instead of JSON over the wire.** This makes for fast first-load pages, keeps template rendering on the server, and allows for a simpler, more productive development experience in any programming language, without sacrificing any of the speed or responsiveness associated with a traditional single-page application.

You can follow the HTML-over-the-wire approach as merely inspiration for your own tooling, or you can use these Hotwire designed frameworks created by the team at [37signals](https://37signals.com) to power [HEY](https://hey.com). They work together, complementing each other to give you a complete solution across all platforms:

## Turbo

The heart of Hotwire is Turbo. A set of complementary techniques for speeding up page changes and form submissions, dividing complex pages into components, and stream partial page updates over WebSocket. All without writing any JavaScript at all. And designed from the start to integrate perfectly with native hybrid applications for iOS and Android.

[Learn more about Turbo](https://turbo.hotwired.dev)

## Stimulus

While Turbo usually takes care of at least 80% of the interactivity that traditionally would have required JavaScript, there are still cases where a dash of custom code is required. Stimulus makes this easy with a HTML-centric approach to state and wiring.

[Learn more about Stimulus](https://stimulus.hotwired.dev)

## Strada

Standardizes the way that web and native parts of a mobile hybrid application talk to each other via HTML bridge attributes. This makes it easy to progressively level-up web interactions with native replacements.

[Learn more about Strada](https://strada.hotwired.dev)

Brought to you by the makers of:
[Basecamp](https://basecamp.com)
and
[HEY](https://hey.com)

Â© 2023 [37signals](https://37signals.com)

## Hotwire intro demo video transcript:

Welcome to Hotwire, an umbrella for trio frameworks that implement the HTML-over-the-wire approach to building modern web applications. At its heart is Turbo, which gives you techniques for bringing the speed of a single-page application without writing a lick of JavaScript. This screencast will focus primarily on showing how Turbo works. But most applications will eventually need a few sprinkles of JavaScript to get the fidelity they need. And for that purpose, we have Stimulus. It's a modest JavaScript framework for the HTML you already have. I'll briefly show how this works to supplement the Turbo demonstration. Finally, we have Strada, which provides bridge tooling for how the web and native parts of a mobile hybrid application built with Hotwire talk to each other. We're still working on polishing Strada for release, so this screencast will not cover it. Hotwire is what we've used to implement all of the front-end elements of hey.com, the new email service by Basecamp. We're going to build a chat application using vanilla Rails plus the Hotwire Rails integration gem, which includes the full setup for Turbo and Stimulus. The Hotwire install command will turn on Redis backing for handling WebSockets with Action Cable at the import map needed for autoloading Stimulus controllers and a few other tweaks. The application will use two models, Room and Message. One Room has many Messages. We'll use a full scaffold for the Room model to give us the basic editing interface, but only use the model generator for Message since it needs much less. We're going to connect Room and Message together without using any of Hotwire to start. This will give us a foundation flow for an admittedly cumbersome chat application which we can then use to level up with Hotwire techniques one at a time. For Messages, we'll have just two actions. New to render the form to create a message, and Create to handle the form submission. Note that we are also adding a partial template to encapsulate rendering of the Message. This partial is then rendered when showing the Room relying on the conventional naming to tie them together. This is all just standard, one-on-one rail stuff, but let's start the server and try it out. Hello, Rails. Here's our interface to create a new Room. Then we create a couple of new Messages for that Room. Yes, technically a chat system, but not exactly a very dynamic or appealing one. So let's introduce our first Turbo feature, Frames. Turbo Frames decompose pages into independent contexts, which can be lazy-loaded and scope interaction. So when you follow a link or submit a form, only the content of the Frame changes rather than the entire page. This allows you to keep the state of the rest of the page from changing, making the app feel more responsive. To be able to easily see how the Frames work, we'll call them out with a blue border. Now let's wrap the Room name and the ability to edit it inside a Frame. The Turbo Frame tag goes around both the initial display, including the Edit link, and the part of the Edit page we want to appear within the Frame. We see our Frame wrapped in blue. And when clicking the Edit link, the form from the Edit screen is presented within. And upon submission, it's replaced again with just a display. If we go straight to the full page editing screen, we can see it has both a header and navigation links, parts we were emitting from the Frame. Note that if we try to click a link within the Frame that goes somewhere without a matching Frame, nothing happens. We can solve this by adding a Data Turbo Frame attribute that points to underscore top to break out of the Frame, just like traditional HTML frames. Now the back link works and the Frame scopes the Edit Display loop. Then let's add the New Message link into an inline but lazy-loaded Turbo Frame tag that also, just for starters, acts on the whole page. This Frame will be loaded right after the page displays, hitting the New Message Controller action we made earlier. Like with Edit, we wrap the relevant segment in a Frame tag with a matching ID, which is how Turbo knows how to plug out the right Frame. You can now see two requests when we load the room-- one for the page, one for the lazy-loader frame. Let's try to add a message. It works! But this only demonstrates that the Frame was lazy-loaded. Right now, we're resetting the whole page upon submission of the New Message form. Whereas with the Room Name Frame, you can edit and submit without changing the rest of the page state, a real independent context. You can see how the Frame replacement happens by inspecting the response to edit. Rails knows when a request is coming from a Frame, so it won't render the layout, but that's just a nice-to-have have optimization. Turbo will plug out just the matching Frame, regardless of whether the response is optimized or not. As you can see here, the header and links are ignored. Now let's turn to Turbo Streams. They deliver page changes over WebSocket or in response to form submissions using just HTML and a set of CRUD like action tags. The tags let you append or prepend to replace and remove any target dom element from the existing page. They're strictly limited to dom changes, though. No direct JavaScript invocation. If you need more than dom change, connect a Stimulus controller. We will add a Turbo stream response to the message creation action such that we can add the new Message to the Room page without replacing the whole page. This template invokes the Append action with the dom ID of the target container, and either a full set of partial rendering options or just a record we wish to render which conforms to the naming conventions for matching to a partial. Now we can add Messages to the page without resetting it completely. The Edit Name form can stay open while we're doing this, because new Messages are added directly to the Messages div. The Turbo Stream HTML is rendered directly in response to the form submission, and Turbo knows from the MIME type to process it automatically. But notice the input field isn't cleared. We can fix that by adding a Stimulus controller. The new Rail Stimulus integration gem ships with an autoloader for you controllers. This is done with an import map supported by es-module-shim, and the unprocessed ES6 controller code that's loaded by the browser directly via ESM. You can of course continue to use Stimulus with your existing JavaScript bundler and transpiler, but this gives you a taste of how far we're able to get with native browser controls now. The Stimulus controller we're going to add will be a dead simple way to reset the form after creating a new Message. It has just one method, Reset, which we will call when Turbo is done submitting the form via Fetch. The only novel part here compared to existing Stimulus is how we'll audit load the controller at runtime using ESM when the data controller attribute is spotted in the dom. Reload to pick up the new Stimulus controller. Then let's add another Message. And voila! The form is reset and the Message added dynamically. But how interesting is a chat app where you're just talking to yourself? Let's start a conversation with another window. You'll see that new Messages are only added live to the originator's window. On the other side, we have to reload to see what's been said. Let's fix that. The first thing we'll do is establish a WebSocket connection to the stream identified by the Room we're in. This is done with a Turbo Stream From tag using a tamper-safe signed identifier in the view. You can see the connection has been made to the Turbo Stream's channel running over action cable from the inclusion of this text. Let's send new Messages to this Stream by adding a broadcast call to the Message creation. This method call mirrors what we're already doing in the Turbo Stream template, just over WebSocket now. Now we can add a new message and see it appear in both windows. But you'll see the originator sees double, because the Turbo Stream response from the form submission is still in place. On the other side, we can inspect the traffic on the action cable WebSocket and see that the very same message partial is being used to render the update over there, wrapped with the same Turbo Stream tag. There, we don't have a form submission, so the message is only added once. Let's fix the double vision by removing the Turbo Stream returned in response to the form submission. For now, we'll just leave a note to document the dead end this will be without a cable connection. And now all updates are sent only once. We can also Turbo Stream deleting messages. We'll add a similar model call back and destroy the triggers that remove broadcasts sent to the same Stream. But instead of adding in a UI, let's try to invoke this flow from the console. Here, you can see the destroy carried out, didn't spot the broadcast sent using the Turbo Stream Remove Action tag. I call it again. Another line disappears from both browser windows. You can also create a new message straight from the console. And here, you'll see the same Turbo Stream Append action with the same partial template, as with all the other examples. Finally, we can add a replace to happen with the message is updated. This follows the same flow and completes the life cycle of callbacks you'd normally respond to with Stream updates. Let's invoke from the console. Whoops! We have to reload our console instance to pick up the code change. And here we go. The last message in the chat has been updated. But it can be even simpler. If you want a full menu of basic lifecycle updates, you can replace these three callbacks with a single broadcast to declaration. You'll notice that this setup even uses async broadcasts. Surrendering is done out of band by a job queue. Let's add this shortened form directly to changing the room as well. Since the room identifies the Stream, we could just use broadcasts. Then we'll extract the room display as its own partial so it'll match the conventions assumed by the callback, render it in line, and give it a dom ID. Now you can edit the name in one window and instantly see it updated in the other. So that's Hotwire, an alternative approach to building modern web applications without using much JavaScript by sending HTML instead of JSON over the wire. We get to keep all our template rendering on the server, which means writing more of our application in our favorite programming languages. Now let's have a quick look at how these techniques are used in a real-life application. We at Basecamp launched our new email service, hey.com, this past summer. And within 40 kilobytes of compressed JavaScript, we're able to deliver a full featured modern and successful email app, complete with native applications across all the major platforms, powered by the same majestic monolith running on Hotwire. HEY uses lazy-loaded Turbo Frames to fetch the Reply Later and Set Aside trays at the bottom of the inbox. These trays change far less frequently than the inbox itself, so they're excellent candidates to run on a different caching schedule. They're loaded as soon as the initial page is loaded, but will 302 when already cached when you hit them a second time. We also use lazy-loaded Turbo Frames for menus, but these are not loaded until you access them for the first time. Once loaded, you'll be hitting that browser cache on subsequent visits. This technique is used for both the HEY menu and the ME menu, both triggered by the detailed summary tag pairing. The Topic page uses even more lazy-loaded Turbo Frames, since the basic page is shared amongst all users on a company account for maximum cache efficiency and all per-user specialization is therefore done with Frames. But let's focus just on the Toolbar Frame, which is where you start a new reply. When Reply Now is pressed, that Frame is replaced with a Frame response of the New Message page. If we delete that response, we again replace the Frame with the toolbar. Barely any JavaScript needed for the whole interaction. Now let's go back and have a look at the Screener. The Screener actions are synchronized between browser windows, just like in our chat demo application. Although here, updates needed for different pages require unique responses. So we simply remove the pending email from the Screener upon clicking the button, but we update both the Screener button and reveal the Screened in email in the inbox on the other screen. You'll see we're still using a slightly older Turbo Stream syntax here, with a template tag as the head, but we'll be changing to the latest API shortly. Lastly, you'll see how Frames and Streams can interact. When you set aside an email, we remove it from the inbox, then add it to the Set Aside tray in both windows at once. The removal in the Acting window is done via Turbo Stream response to the action, and then both windows have the Set Aside email added to the tray over WebSocket. You can check out all the ways we've used Hotwire to build HEY by signing up for free trial account. All the JavaScript is available with source maps. All the Turbo interactions were sent in the clear, so there's plenty to learn from, and we welcome you to borrow or steal our Stimulus controllers. I hope you've enjoyed this quick tour of Hotwire, and Turbo in particular. Please help us further develop all the frameworks as open source. Thanks. 